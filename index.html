<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iliad - P2P Board Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.1/peerjs.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #2c1810 0%, #4a2420 100%);
            color: #f5e6d3;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        #gameContainer {
            max-width: 1200px;
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        }
        #connectionPanel {
            text-align: center;
            padding: 30px;
        }
        #connectionPanel h1 {
            color: #d4af37;
            margin-bottom: 30px;
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        .connection-info {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        input, button {
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            border: none;
            font-size: 16px;
        }
        button {
            background: #d4af37;
            color: #2c1810;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover { background: #e5c348; transform: scale(1.05); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #gameBoard {
            display: none;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(6, 60px);
            grid-template-rows: repeat(6, 60px);
            gap: 2px;
            background: #8b7355;
            padding: 10px;
            border-radius: 10px;
            position: relative;
            margin: 80px;
        }
        #boardBorder {
            position: absolute;
            top: -80px;
            left: -80px;
            right: -80px;
            bottom: -80px;
            border: 75px solid rgba(139, 115, 85, 0.3);
            border-radius: 15px;
            pointer-events: none;
        }
        #tokenDropZone {
            position: absolute;
            top: -75px;
            left: -75px;
            right: -75px;
            bottom: -75px;
            pointer-events: none;
        }
        .tokenSlot {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px dashed rgba(212, 175, 55, 0.3);
            border-radius: 50%;
            pointer-events: all;
        }
        .tokenSlot.occupied {
            border-color: transparent;
        }
        .tokenSlot.dragover {
            background: rgba(212, 175, 55, 0.3);
            border-color: #d4af37;
        }
        .space {
            width: 60px;
            height: 60px;
            border: 2px solid #5a4a3a;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
        }
        .space.blue { background: linear-gradient(135deg, #2e5090, #4a7cc7); }
        .space.red { background: linear-gradient(135deg, #8b2020, #c73a3a); }
        .space:hover { border-color: #d4af37; transform: scale(1.05); }
        .tile {
            width: 50px;
            height: 50px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
            color: white;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
        }
        .tile.blue { background: linear-gradient(135deg, #1e3a6f, #3a5c9e); }
        .tile.red { background: linear-gradient(135deg, #6b1f1f, #9e3a3a); }
        .tile.dolos { background: radial-gradient(circle, #4a4a4a, #1a1a1a); }
        .tile.facedown { background: #3a3a3a; color: transparent; }
        #playerInfo {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
        }
        .tokenStorage {
            min-height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed #d4af37;
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .tokenStorage.dragover {
            background: rgba(212, 175, 55, 0.2);
            border-color: #ffff00;
        }
        #hand {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            min-height: 60px;
        }
        .handTile {
            width: 50px;
            height: 50px;
            border: 2px solid #d4af37;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 20px;
            color: white;
            transition: all 0.3s;
        }
        .handTile.blue { background: linear-gradient(135deg, #1e3a6f, #3a5c9e); }
        .handTile.red { background: linear-gradient(135deg, #6b1f1f, #9e3a3a); }
        .handTile.dolos { background: radial-gradient(circle, #4a4a4a, #1a1a1a) !important; }
        .handTile:hover { transform: scale(1.1); }
        .handTile.selected { border-color: #ffff00; box-shadow: 0 0 15px #ffff00; }
        #successTokenDisplay {
            position: absolute;
            top: -40px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            padding: 0 10px;
        }
        .successToken {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            cursor: grab;
            position: absolute;
            z-index: 100;
            transition: none;
        }
        .successToken:active {
            cursor: grabbing;
        }
        .successToken.dragging {
            opacity: 0.5;
            z-index: 1000;
        }
        .successToken.zeus { background: #6a6a6a; }
        .successToken.apollo { background: #f4a460; }
        .successToken.athena { background: #d8bfd8; }
        .successToken.poseidon { background: #4682b4; }
        .successToken.aphrodite { background: #ff69b4; }
        .successToken.positive { background: #ffd700; color: black; }
        .successToken.negative { background: #8b0000; color: white; }
        .successToken.marriage { background: #90ee90; }
        .tile-mark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            color: #ff0000;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }
        #message {
            text-align: center;
            padding: 10px;
            background: rgba(212, 175, 55, 0.2);
            border-radius: 5px;
            margin-top: 10px;
            min-height: 40px;
        }
        #debugInfo {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="connectionPanel">
            <h1>⚔️ ILIAD ⚔️</h1>
            <div class="connection-info">
                <h3>Start or Join Game</h3>
                <p>Your ID: <strong id="myId">Generating...</strong></p>
                <button id="copyId">Copy My ID</button>
                <br><br>
                <input type="text" id="peerId" placeholder="Enter opponent's ID">
                <button id="connectBtn">Connect</button>
                <br><br>
                <p id="status">Waiting for connection...</p>
            </div>
        </div>
        
        <div id="gameBoard">
            <div id="playerInfo">
                <h3 id="playerRole"></h3>
                <div>Mode: <span id="currentTurn"></span></div>
                <div>Your Token Storage:</div>
                <div id="myTokenStorage" class="tokenStorage"></div>
                <div>Hand: <span id="handCount"></span></div>
                <div id="hand"></div>
                <button id="drawTile" style="margin-top: 10px;">Draw Tile</button>
                <button id="checkLines" style="margin-top: 10px;">Check for Scoring Lines</button>
                <div id="debugInfo"></div>
            </div>
            
            <div>
                <div id="successTokenDisplay"></div>
                <div id="board"></div>
                <div id="message"></div>
                <div id="tileReference" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-top: 15px;">
                    <h4 style="color: #d4af37; margin-bottom: 10px;">Tile Effects Reference</h4>
                    <div style="font-size: 14px;">
                        <div><strong>1:</strong> Reposition one opponent's accessible tile</div>
                        <div><strong>2:</strong> Reposition one of your own accessible tiles</div>
                        <div><strong>3:</strong> Swap a success token (after scoring a line)</div>
                        <div><strong>4:</strong> Flip this tile and one opponent neighbor tile</div>
                        <div><strong>5:</strong> No effect</div>
                        <div><strong>✦ (Dolos):</strong> No effect (counts as 0 in scoring)</div>
                    </div>
                </div>
            </div>
            
            <div id="opponentInfo">
                <h3>Opponent</h3>
                <div>Their Token Storage:</div>
                <div id="oppTokenStorage" class="tokenStorage"></div>
            </div>
        </div>
    </div>

    <script>
        const GODS = ['Zeus', 'Apollo', 'Athena', 'Poseidon', 'Aphrodite'];
        const TILE_VALUES = [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 'D', 'D', 'D'];  // 18 tiles per player
        
        let peer, conn;
        let myId, isHost;
        let gameState = {
            board: Array(36).fill(null),
            currentPlayer: 'blue',
            blueTokens: [],
            redTokens: [],
            successTokens: [],
            tokenPositions: {},  // Track positions of all tokens
            tokenSlots: [],      // Track slot positions around board
            reserveTokens: [],   // Track tokens not initially placed
            blueDeck: [],
            redDeck: [],
            blueHand: [],
            redHand: [],
            phase: 'setup'
        };
        let selectedTile = null;
        let myColor = null;
        let effectMode = null;
        let effectData = null;
        let selectedBoardTile = null;  // Track selected tile from board
        let markedTiles = new Set();  // Track tiles marked with X

        // Initialize PeerJS
        peer = new Peer();
        
        peer.on('open', id => {
            document.getElementById('myId').textContent = id;
            myId = id;
        });

        peer.on('connection', connection => {
            conn = connection;
            isHost = true;
            myColor = 'blue';
            setupConnection();
            initGame();
        });

        document.getElementById('copyId').addEventListener('click', () => {
            navigator.clipboard.writeText(myId);
            document.getElementById('status').textContent = 'ID copied!';
            setTimeout(() => {
                document.getElementById('status').textContent = 'Waiting for connection...';
            }, 2000);
        });

        document.getElementById('connectBtn').addEventListener('click', () => {
            const peerId = document.getElementById('peerId').value;
            if (peerId && peerId !== myId) {
                conn = peer.connect(peerId);
                isHost = false;
                myColor = 'red';
                conn.on('open', () => {
                    setupConnection();
                });
            }
        });

        function setupConnection() {
            document.getElementById('status').textContent = 'Connected!';
            document.getElementById('connectionPanel').style.display = 'none';
            document.getElementById('gameBoard').style.display = 'grid';
            
            conn.on('data', data => {
                if (data.type === 'gameState') {
                    gameState = data.state;
                    updateDisplay();
                    showMessage(`Game state received. Your hand has ${(myColor === 'blue' ? gameState.blueHand : gameState.redHand).length} tiles`);
                } else if (data.type === 'move') {
                    handleOpponentMove(data);
                }
            });
            
            conn.on('close', () => {
                showMessage('Opponent disconnected');
            });
            
            if (isHost) {
                setTimeout(() => sendGameState(), 100);
            }
        }

        function initGame() {
            // Setup board spaces
            for (let i = 0; i < 36; i++) {
                const row = Math.floor(i / 6);
                const col = i % 6;
                const isBlue = (row % 2 === 0) ? (col % 2 === 0) : (col % 2 === 1);
                gameState.board[i] = { color: isBlue ? 'blue' : 'red', tile: null };
            }
            
            // Setup success tokens
            setupSuccessTokens();
            
            // Setup decks
            gameState.blueDeck = shuffleArray([...TILE_VALUES]);
            gameState.redDeck = shuffleArray([...TILE_VALUES]);
            
            // Initial draw
            for (let i = 0; i < 2; i++) {
                gameState.blueHand.push(gameState.blueDeck.pop());
                gameState.redHand.push(gameState.redDeck.pop());
            }
            
            updateDisplay();
            showMessage('Game initialized! Blue starts.');
        }

        function setupSuccessTokens() {
            const tokens = [];
            
            // 5 god tokens with random values 1-10
            GODS.forEach(god => {
                tokens.push({ type: 'god', god, value: Math.floor(Math.random() * 10) + 1, id: `token-${god}` });
            });
            
            // 8 positive tokens (various items, all +10)
            const positiveItems = ['Shield', 'Spear', 'Chariot', 'Helm', 'Sword', 'Bow', 'Armor', 'Horse'];
            positiveItems.forEach((item, i) => {
                tokens.push({ type: 'positive', item, value: 10, id: `token-positive-${i}` });
            });
            
            // 8 negative tokens (various penalties)
            const negativeItems = [
                { item: 'Weakened', value: -3 },
                { item: 'Morale', value: -3 },
                { item: 'Plague', value: -5 },
                { item: 'Discord', value: -5 },
                { item: 'Exhaustion', value: -5 },
                { item: 'Famine', value: -10 },
                { item: 'Firestorm', value: -10 },
                { item: 'Curse', value: -10 }
            ];
            negativeItems.forEach((neg, i) => {
                tokens.push({ type: 'negative', item: neg.item, value: neg.value, id: `token-negative-${i}` });
            });
            
            // 2 marriage tokens (Helen)
            tokens.push({ type: 'marriage', value: 0, id: 'token-marriage1' });
            tokens.push({ type: 'marriage', value: 0, id: 'token-marriage2' });
            
            // 6 additional mixed tokens to reach 29 total
            tokens.push({ type: 'positive', item: 'Glory', value: 10, id: 'token-glory' });
            tokens.push({ type: 'positive', item: 'Favor', value: 10, id: 'token-favor' });
            tokens.push({ type: 'negative', item: 'Betrayal', value: -5, id: 'token-betrayal' });
            tokens.push({ type: 'negative', item: 'Storm', value: -5, id: 'token-storm' });
            tokens.push({ type: 'positive', item: 'Victory', value: 10, id: 'token-victory' });
            tokens.push({ type: 'negative', item: 'Defeat', value: -10, id: 'token-defeat' });
            
            // Shuffle all tokens
            let shuffledTokens = shuffleArray(tokens);
            
            // Select 24 tokens for initial board placement
            let boardTokens = [];
            let reserveTokens = [];
            let nonNegCount = 0;
            
            // First ensure 5 non-negative tokens are in the initial placement
            for (let i = 0; i < shuffledTokens.length && boardTokens.length < 5; i++) {
                if (shuffledTokens[i].value >= 0) {
                    boardTokens.push(shuffledTokens[i]);
                    shuffledTokens.splice(i, 1);
                    i--;
                }
            }
            
            // Randomly select 19 more tokens to reach 24 total on board
            shuffledTokens = shuffleArray(shuffledTokens);
            boardTokens = [...boardTokens, ...shuffledTokens.slice(0, 19)];
            reserveTokens = shuffledTokens.slice(19);
            
            // Shuffle board tokens for random placement
            boardTokens = shuffleArray(boardTokens);
            
            // Create token slots around the board - 24 slots for initial placement
            gameState.tokenSlots = [];
            const totalSlots = 24;
            const boardSize = 380; // 6*60 + 2*10 padding
            const borderOffset = 40; // Distance from board edge to center of tokens
            
            for (let i = 0; i < totalSlots; i++) {
                let x, y;
                
                // Distribute 24 tokens evenly: 6 per side
                if (i < 6) {
                    // Top edge (6 tokens)
                    const spacing = boardSize / 6;
                    x = -borderOffset + spacing/2 + (i * spacing);
                    y = -borderOffset;
                } else if (i < 12) {
                    // Right edge (6 tokens)
                    const spacing = boardSize / 6;
                    x = boardSize + borderOffset;
                    y = -borderOffset + spacing/2 + ((i - 6) * spacing);
                } else if (i < 18) {
                    // Bottom edge (6 tokens)
                    const spacing = boardSize / 6;
                    x = boardSize + borderOffset - spacing/2 - ((i - 12) * spacing);
                    y = boardSize + borderOffset;
                } else {
                    // Left edge (6 tokens)
                    const spacing = boardSize / 6;
                    x = -borderOffset;
                    y = boardSize + borderOffset - spacing/2 - ((i - 18) * spacing);
                }
                
                gameState.tokenSlots.push({ x, y, occupied: false, index: i });
            }
            
            // Place 24 tokens in slots
            boardTokens.forEach((token, i) => {
                if (i < gameState.tokenSlots.length) {
                    const slot = gameState.tokenSlots[i];
                    gameState.tokenPositions[token.id] = {
                        x: slot.x,
                        y: slot.y,
                        location: 'board',
                        slotIndex: i
                    };
                    slot.occupied = token.id;
                }
            });
            
            // Store reserve tokens (5 tokens not initially on board)
            reserveTokens.forEach(token => {
                gameState.tokenPositions[token.id] = {
                    x: 0,
                    y: 0,
                    location: 'reserve'
                };
            });
            
            // Combine all tokens but only display the 24 on board
            gameState.successTokens = [...boardTokens, ...reserveTokens];
            gameState.reserveTokens = reserveTokens.map(t => t.id);
        }

        function updateDisplay() {
            // Update player info
            document.getElementById('playerRole').textContent = 
                myColor === 'blue' ? '🛡️ Hector (Blue)' : '⚔️ Achilles (Red)';
            document.getElementById('currentTurn').textContent = 'Free Play Mode';
            
            // Update board
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            gameState.board.forEach((space, i) => {
                const spaceEl = document.createElement('div');
                spaceEl.className = `space ${space.color}`;
                spaceEl.dataset.index = i;
                
                if (space.tile) {
                    const tileEl = document.createElement('div');
                    tileEl.className = `tile ${space.tile.color}`;
                    if (space.tile.facedown) {
                        tileEl.classList.add('facedown');
                    } else if (space.tile.value === 'D') {
                        tileEl.classList.add('dolos');
                        tileEl.textContent = '✦';
                    } else {
                        tileEl.textContent = space.tile.value;
                    }
                    
                    // Add X mark if tile is marked
                    if (markedTiles.has(i)) {
                        const markEl = document.createElement('div');
                        markEl.className = 'tile-mark';
                        markEl.textContent = '✕';
                        tileEl.appendChild(markEl);
                    }
                    
                    spaceEl.appendChild(tileEl);
                }
                
                if (selectedBoardTile === i) {
                    spaceEl.style.border = '3px solid #ffff00';
                    spaceEl.style.boxShadow = '0 0 10px #ffff00';
                }
                
                spaceEl.addEventListener('click', () => handleBoardClick(i));
                
                // Add right-click to mark tiles
                spaceEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    
                    if (space.tile) {
                        if (markedTiles.has(i)) {
                            markedTiles.delete(i);
                            showMessage("Removed X mark");
                        } else {
                            markedTiles.add(i);
                            showMessage("Added X mark");
                        }
                        updateDisplay();
                        
                        // Send mark update to opponent
                        sendMove({ action: 'toggleMark', index: i, marked: markedTiles.has(i) });
                    }
                });
                boardEl.appendChild(spaceEl);
            });
            
            updateBoardTokens();
            updateHand();
        }

        function updateHand() {
            const handEl = document.getElementById('hand');
            handEl.innerHTML = '';
            const myHand = myColor === 'blue' ? gameState.blueHand : gameState.redHand;
            
            document.getElementById('handCount').textContent = `(${myHand.length} tiles)`;
            
            myHand.forEach((tile, i) => {
                const tileEl = document.createElement('div');
                tileEl.className = `handTile ${myColor}`;
                
                if (tile === 'D') {
                    tileEl.classList.add('dolos');
                    tileEl.textContent = '✦';
                } else {
                    tileEl.textContent = tile;
                }
                
                if (selectedTile === i) {
                    tileEl.classList.add('selected');
                }
                
                tileEl.addEventListener('click', () => selectTile(i));
                handEl.appendChild(tileEl);
            });
            
            // Debug info
            document.getElementById('debugInfo').innerHTML = `
                Deck: ${(myColor === 'blue' ? gameState.blueDeck : gameState.redDeck).length}/18 tiles remaining<br>
                Hand values: [${myHand.join(', ')}]
            `;
        }

        function updateTokenDisplay() {
            const myTokensEl = document.getElementById('myTokens');
            const oppTokensEl = document.getElementById('oppTokens');
            const myTokens = myColor === 'blue' ? gameState.blueTokens : gameState.redTokens;
            const oppTokens = myColor === 'blue' ? gameState.redTokens : gameState.blueTokens;
            
            myTokensEl.innerHTML = '';
            oppTokensEl.innerHTML = '';
            
            myTokens.forEach(token => {
                const tokenEl = createTokenElement(token);
                myTokensEl.appendChild(tokenEl);
            });
            
            oppTokens.forEach(token => {
                const tokenEl = createTokenElement(token);
                oppTokensEl.appendChild(tokenEl);
            });
        }

        function createTokenElement(token) {
            const tokenEl = document.createElement('div');
            tokenEl.className = 'token';
            
            if (token.type === 'god') {
                tokenEl.classList.add(token.god.toLowerCase());
                tokenEl.textContent = token.god[0] + token.value;
            } else if (token.type === 'positive') {
                tokenEl.classList.add('positive');
                tokenEl.textContent = '+' + token.value;
            } else if (token.type === 'negative') {
                tokenEl.classList.add('negative');
                tokenEl.textContent = token.value;
            } else if (token.type === 'marriage') {
                tokenEl.classList.add('marriage');
                tokenEl.textContent = '💍';
            }
            
            return tokenEl;
        }

        function updateBoardTokens() {
            // Remove old token display
            document.getElementById('successTokenDisplay').innerHTML = '';
            
            // Remove existing draggable tokens and slots
            document.querySelectorAll('.successToken').forEach(el => el.remove());
            document.querySelectorAll('.tokenSlot').forEach(el => el.remove());
            
            // Remove old event listeners
            const boardContainer = document.getElementById('board').parentElement;
            const newBoardContainer = boardContainer.cloneNode(true);
            boardContainer.parentNode.replaceChild(newBoardContainer, boardContainer);
            
            const boardEl = newBoardContainer.querySelector('#board');
            boardEl.innerHTML = '';
            
            // Create border and drop zone
            let borderEl = newBoardContainer.querySelector('#boardBorder');
            if (!borderEl) {
                borderEl = document.createElement('div');
                borderEl.id = 'boardBorder';
                newBoardContainer.appendChild(borderEl);
            }
            
            let dropZone = newBoardContainer.querySelector('#tokenDropZone');
            if (!dropZone) {
                dropZone = document.createElement('div');
                dropZone.id = 'tokenDropZone';
                newBoardContainer.appendChild(dropZone);
            }
            
            // Create token slots
            if (gameState.tokenSlots) {
                gameState.tokenSlots.forEach(slot => {
                    const slotEl = document.createElement('div');
                    slotEl.className = 'tokenSlot';
                    slotEl.dataset.slotIndex = slot.index;
                    slotEl.style.left = (slot.x + 75) + 'px'; // Adjust for larger border
                    slotEl.style.top = (slot.y + 75) + 'px';
                    
                    if (slot.occupied) {
                        slotEl.classList.add('occupied');
                    }
                    
                    slotEl.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        slotEl.classList.add('dragover');
                    });
                    
                    slotEl.addEventListener('dragleave', () => {
                        slotEl.classList.remove('dragover');
                    });
                    
                    slotEl.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        slotEl.classList.remove('dragover');
                        handleSlotDrop(e, slot.index);
                    });
                    
                    dropZone.appendChild(slotEl);
                });
            }
            
            // Recreate board spaces
            gameState.board.forEach((space, i) => {
                const spaceEl = document.createElement('div');
                spaceEl.className = `space ${space.color}`;
                spaceEl.dataset.index = i;
                
                if (space.tile) {
                    const tileEl = document.createElement('div');
                    tileEl.className = `tile ${space.tile.color}`;
                    if (space.tile.facedown) {
                        tileEl.classList.add('facedown');
                    } else if (space.tile.value === 'D') {
                        tileEl.classList.add('dolos');
                        tileEl.textContent = '✦';
                    } else {
                        tileEl.textContent = space.tile.value;
                    }
                    
                    // Add X mark if tile is marked
                    if (markedTiles.has(i)) {
                        const markEl = document.createElement('div');
                        markEl.className = 'tile-mark';
                        markEl.textContent = '✕';
                        tileEl.appendChild(markEl);
                    }
                    
                    spaceEl.appendChild(tileEl);
                }
                
                if (selectedBoardTile === i) {
                    spaceEl.style.border = '3px solid #ffff00';
                    spaceEl.style.boxShadow = '0 0 10px #ffff00';
                }
                
                spaceEl.addEventListener('click', () => handleBoardClick(i));
                
                // Add right-click to mark tiles
                spaceEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    
                    if (space.tile) {
                        if (markedTiles.has(i)) {
                            markedTiles.delete(i);
                            showMessage("Removed X mark");
                        } else {
                            markedTiles.add(i);
                            showMessage("Added X mark");
                        }
                        updateDisplay();
                        
                        // Send mark update to opponent
                        sendMove({ action: 'toggleMark', index: i, marked: markedTiles.has(i) });
                    }
                });
                
                boardEl.appendChild(spaceEl);
            });
            
            newBoardContainer.style.position = 'relative';
            
            // Create draggable tokens
            gameState.successTokens.forEach(token => {
                // Skip reserve tokens (not on board initially)
                const pos = gameState.tokenPositions[token.id];
                if (pos.location === 'reserve') return;
                
                const tokenEl = document.createElement('div');
                tokenEl.className = 'successToken';
                tokenEl.id = token.id;
                tokenEl.draggable = true;
                
                // Set token appearance
                if (token.type === 'god') {
                    tokenEl.classList.add(token.god.toLowerCase());
                    tokenEl.textContent = token.god[0] + token.value;
                    tokenEl.title = `${token.god}: ${token.value}`;
                } else if (token.type === 'positive') {
                    tokenEl.classList.add('positive');
                    tokenEl.textContent = '+' + token.value;
                    tokenEl.title = `${token.item}: +${token.value}`;
                } else if (token.type === 'negative') {
                    tokenEl.classList.add('negative');
                    tokenEl.textContent = token.value;
                    tokenEl.title = `${token.item}: ${token.value}`;
                } else if (token.type === 'marriage') {
                    tokenEl.classList.add('marriage');
                    tokenEl.textContent = '💍';
                    tokenEl.title = 'Marriage to Helen';
                }
                
                // Set position (using already declared pos variable)
                if (pos.location === 'board') {
                    tokenEl.style.left = (pos.x + 75) + 'px'; // Adjust for larger border
                    tokenEl.style.top = (pos.y + 75) + 'px';
                    newBoardContainer.appendChild(tokenEl);
                } else if (pos.location === myColor) {
                    tokenEl.style.position = 'relative';
                    tokenEl.style.left = '';
                    tokenEl.style.top = '';
                    document.getElementById('myTokenStorage').appendChild(tokenEl);
                } else if (pos.location === (myColor === 'blue' ? 'red' : 'blue')) {
                    tokenEl.style.position = 'relative';
                    tokenEl.style.left = '';
                    tokenEl.style.top = '';
                    document.getElementById('oppTokenStorage').appendChild(tokenEl);
                }
                
                // Add drag event listeners
                tokenEl.addEventListener('dragstart', handleTokenDragStart);
                tokenEl.addEventListener('dragend', handleTokenDragEnd);
            });
            
            // Add drop zone listeners
            newBoardContainer.addEventListener('dragover', handleBoardDragOver);
            newBoardContainer.addEventListener('drop', handleBoardDrop);
            
            const myStorage = document.getElementById('myTokenStorage');
            const newMyStorage = myStorage.cloneNode(false);
            myStorage.parentNode.replaceChild(newMyStorage, myStorage);
            
            // Move tokens to new storage
            document.querySelectorAll('.successToken').forEach(token => {
                const pos = gameState.tokenPositions[token.id];
                if (pos && pos.location === myColor) {
                    newMyStorage.appendChild(token);
                }
            });
            
            newMyStorage.addEventListener('dragover', handleStorageDragOver);
            newMyStorage.addEventListener('drop', handleStorageDrop);
            newMyStorage.addEventListener('dragleave', handleStorageDragLeave);
        }
        
        let draggedToken = null;
        
        function handleTokenDragStart(e) {
            draggedToken = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            
            // Clear old slot if token was in one
            const tokenId = e.target.id;
            const pos = gameState.tokenPositions[tokenId];
            if (pos && pos.slotIndex !== undefined) {
                const slot = gameState.tokenSlots[pos.slotIndex];
                if (slot) {
                    slot.occupied = false;
                }
            }
        }
        
        function handleTokenDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedToken = null;
        }
        
        function handleBoardDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        
        function handleBoardDrop(e) {
            e.preventDefault();
            if (!draggedToken) return;
            
            const boardContainer = document.getElementById('board').parentElement;
            const rect = boardContainer.getBoundingClientRect();
            const x = e.clientX - rect.left - 75; // Adjust for larger border
            const y = e.clientY - rect.top - 75;
            
            const tokenId = draggedToken.id;
            gameState.tokenPositions[tokenId] = { x, y, location: 'board' };
            
            draggedToken.style.position = 'absolute';
            draggedToken.style.left = (x + 75) + 'px';
            draggedToken.style.top = (y + 75) + 'px';
            boardContainer.appendChild(draggedToken);
            
            sendMove({ action: 'moveToken', tokenId, position: gameState.tokenPositions[tokenId] });
        }
        
        function handleSlotDrop(e, slotIndex) {
            if (!draggedToken) return;
            
            const slot = gameState.tokenSlots[slotIndex];
            const tokenId = draggedToken.id;
            
            // Clear any other slot that might have this token
            gameState.tokenSlots.forEach(s => {
                if (s.occupied === tokenId) {
                    s.occupied = false;
                }
            });
            
            // Place token in slot
            slot.occupied = tokenId;
            gameState.tokenPositions[tokenId] = { 
                x: slot.x, 
                y: slot.y, 
                location: 'board',
                slotIndex: slotIndex
            };
            
            const boardContainer = document.getElementById('board').parentElement;
            draggedToken.style.position = 'absolute';
            draggedToken.style.left = (slot.x + 75) + 'px';
            draggedToken.style.top = (slot.y + 75) + 'px';
            boardContainer.appendChild(draggedToken);
            
            sendMove({ action: 'moveToken', tokenId, position: gameState.tokenPositions[tokenId] });
        }
        
        function handleStorageDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.currentTarget.classList.add('dragover');
        }
        
        function handleStorageDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }
        
        function handleStorageDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            if (!draggedToken) return;
            
            const tokenId = draggedToken.id;
            gameState.tokenPositions[tokenId] = { x: 0, y: 0, location: myColor };
            
            draggedToken.style.position = 'relative';
            draggedToken.style.left = '';
            draggedToken.style.top = '';
            e.currentTarget.appendChild(draggedToken);
            
            sendMove({ action: 'moveToken', tokenId, position: gameState.tokenPositions[tokenId] });
        }

        function getGodColor(god) {
            const colors = {
                'Zeus': '#6a6a6a',
                'Apollo': '#f4a460',
                'Athena': '#d8bfd8',
                'Poseidon': '#4682b4',
                'Aphrodite': '#ff69b4'
            };
            return colors[god] || '#808080';
        }

        function selectTile(index) {
            selectedTile = selectedTile === index ? null : index;
            updateHand();
            if (selectedTile !== null) {
                const myHand = myColor === 'blue' ? gameState.blueHand : gameState.redHand;
                showMessage(`Selected tile: ${myHand[selectedTile]}`);
            }
        }

        function handleBoardClick(index) {
            if (effectMode) {
                handleEffectClick(index);
                return;
            }
            
            const space = gameState.board[index];
            
            // If clicking on an existing tile
            if (space.tile) {
                // Only allow picking up your own tiles (unless in effect mode)
                if (space.tile.color === myColor) {
                    if (selectedBoardTile === index) {
                        // Deselect if clicking same tile
                        selectedBoardTile = null;
                        showMessage("Tile deselected");
                    } else {
                        // Pick up the tile
                        selectedBoardTile = index;
                        selectedTile = null; // Deselect hand tile if any
                        showMessage(`Picked up ${space.tile.value} tile. Click empty space to reposition.`);
                    }
                    updateDisplay();
                    return;
                } else {
                    showMessage("You can only move your own tiles!");
                    return;
                }
            }
            
            // If we have a board tile selected, try to place it
            if (selectedBoardTile !== null) {
                const sourceTile = gameState.board[selectedBoardTile].tile;
                
                // Check if new position is valid
                if (space.color !== myColor && !hasNeighborExcept(index, selectedBoardTile)) {
                    showMessage("Can only place on your color or adjacent to existing tiles!");
                    return;
                }
                
                // Move the tile
                gameState.board[selectedBoardTile].tile = null;
                space.tile = sourceTile;
                
                // Send move
                sendMove({ action: 'reposition', from: selectedBoardTile, to: index, tile: sourceTile });
                
                selectedBoardTile = null;
                updateDisplay();
                showMessage(`Moved tile to new position`);
                return;
            }
            
            // If we have a hand tile selected, place it normally
            if (selectedTile === null) {
                showMessage("Select a tile from your hand or board first!");
                return;
            }
            
            if (space.color !== myColor && !hasNeighbor(index)) {
                showMessage("Can only place on your color or adjacent to existing tiles!");
                return;
            }
            
            const myHand = myColor === 'blue' ? gameState.blueHand : gameState.redHand;
            const tileValue = myHand[selectedTile];
            
            // Place tile
            space.tile = { value: tileValue, color: myColor, facedown: false };
            myHand.splice(selectedTile, 1);
            selectedTile = null;
            
            // Send move first
            sendMove({ action: 'placeTile', index, tile: space.tile });
            
            // Apply effect
            if (tileValue !== 'D' && tileValue !== 5) {
                applyTileEffect(tileValue, index);
            }
            
            updateDisplay();
        }

        function hasNeighbor(index) {
            const neighbors = getNeighbors(index);
            return neighbors.some(i => gameState.board[i] && gameState.board[i].tile);
        }

        function getNeighbors(index) {
            const neighbors = [];
            const row = Math.floor(index / 6);
            const col = index % 6;
            
            if (row > 0) neighbors.push(index - 6);
            if (row < 5) neighbors.push(index + 6);
            if (col > 0) neighbors.push(index - 1);
            if (col < 5) neighbors.push(index + 1);
            
            return neighbors;
        }

        function getGodColor(god) {
            const colors = {
                'Zeus': '#6a6a6a',
                'Apollo': '#f4a460',
                'Athena': '#d8bfd8',
                'Poseidon': '#4682b4',
                'Aphrodite': '#ff69b4'
            };
            return colors[god] || '#808080';
        }

        function hasNeighborExcept(index, exceptIndex) {
            const neighbors = getNeighbors(index);
            return neighbors.some(i => i !== exceptIndex && gameState.board[i] && gameState.board[i].tile);
        }

        function applyTileEffect(value, index) {
            switch(value) {
                case 1:
                    showMessage("Effect: Click an opponent's tile to reposition");
                    effectMode = 'reposition-opponent';
                    break;
                case 2:
                    showMessage("Effect: Click your tile to reposition");
                    effectMode = 'reposition-own';
                    break;
                case 3:
                    showMessage("Effect: Token swap not implemented - no effect");
                    // Token swapping would need to be implemented after line scoring
                    break;
                case 4:
                    showMessage("Effect: Players may mark tiles with X (right-click tiles)");
                    // No automatic flipping - players handle this manually
                    break;
                default:
                    break;
            }
        }

        function handleEffectClick(index) {
            const space = gameState.board[index];
            
            if (effectMode === 'reposition-opponent') {
                if (space.tile && space.tile.color !== myColor && isAccessible(index)) {
                    const tile = space.tile;
                    space.tile = null;
                    effectMode = 'place-repositioned';
                    effectData = tile;
                    showMessage("Click empty space to place tile");
                    sendMove({ action: 'reposition', from: index });
                }
            } else if (effectMode === 'reposition-own') {
                if (space.tile && space.tile.color === myColor && isAccessible(index)) {
                    const tile = space.tile;
                    space.tile = null;
                    effectMode = 'place-repositioned';
                    effectData = tile;
                    showMessage("Click empty space to place tile");
                    sendMove({ action: 'reposition', from: index });
                }
            } else if (effectMode === 'place-repositioned') {
                if (!space.tile && (space.color === effectData.color || hasNeighbor(index))) {
                    space.tile = effectData;
                    effectMode = null;
                    effectData = null;
                    sendMove({ action: 'placeRepositioned', to: index, tile: space.tile });
                }
            }
            
            updateDisplay();
        }

        function isAccessible(index) {
            const neighbors = getNeighbors(index);
            return neighbors.some(i => !gameState.board[i] || !gameState.board[i].tile);
        }

        function checkLines() {
            // Check rows
            for (let row = 0; row < 6; row++) {
                if (isLineFull(row * 6, 1)) {
                    scoreLine(row * 6, 1);
                }
            }
            // Check columns
            for (let col = 0; col < 6; col++) {
                if (isLineFull(col, 6)) {
                    scoreLine(col, 6);
                }
            }
        }

        function isLineFull(start, step) {
            for (let i = 0; i < 6; i++) {
                if (!gameState.board[start + i * step].tile) return false;
            }
            return true;
        }

        function scoreLine(start, step) {
            const blueTiles = [];
            const redTiles = [];
            
            for (let i = 0; i < 6; i++) {
                const tile = gameState.board[start + i * step].tile;
                if (tile && !tile.facedown) {
                    if (tile.color === 'blue') {
                        blueTiles.push(tile.value === 'D' ? 0 : tile.value);
                    } else {
                        redTiles.push(tile.value === 'D' ? 0 : tile.value);
                    }
                }
            }
            
            const blueScore = blueTiles.reduce((a, b) => a + b, 0);
            const redScore = redTiles.reduce((a, b) => a + b, 0);
            
            showMessage(`Line scored! Blue: ${blueScore}, Red: ${redScore}`);
        }

        function endTurn() {
            checkLines();
            updateDisplay();
            sendGameState();
        }

        function handleOpponentMove(data) {
            if (data.action === 'placeTile') {
                gameState.board[data.index].tile = data.tile;
            } else if (data.action === 'reposition') {
                gameState.board[data.from].tile = null;
                gameState.board[data.to].tile = data.tile;
            } else if (data.action === 'placeRepositioned') {
                gameState.board[data.to].tile = data.tile;
            } else if (data.action === 'toggleMark') {
                if (data.marked) {
                    markedTiles.add(data.index);
                } else {
                    markedTiles.delete(data.index);
                }
            } else if (data.action === 'moveToken') {
                gameState.tokenPositions[data.tokenId] = data.position;
            }
            updateDisplay();
        }

        function sendMove(move) {
            if (conn && conn.open) {
                conn.send({ type: 'move', ...move });
            }
        }

        function sendGameState() {
            if (conn && conn.open) {
                conn.send({ type: 'gameState', state: gameState });
            }
        }

        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        document.getElementById('drawTile').addEventListener('click', () => {
            const myHand = myColor === 'blue' ? gameState.blueHand : gameState.redHand;
            const myDeck = myColor === 'blue' ? gameState.blueDeck : gameState.redDeck;
            
            if (myHand.length < 2 && myDeck.length > 0) {
                myHand.push(myDeck.pop());
                updateDisplay();
                sendGameState();
                showMessage(`Drew tile: ${myHand[myHand.length - 1]}`);
            } else if (myDeck.length === 0) {
                showMessage("No more tiles in deck!");
            } else {
                showMessage("Hand is full (max 2 tiles)!");
            }
        });
        
        document.getElementById('checkLines').addEventListener('click', () => {
            checkLines();
            sendGameState();
        });
    </script>
</body>
</html>
