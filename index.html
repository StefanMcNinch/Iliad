<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iliad - P2P Board Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.1/peerjs.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #2c1810 0%, #4a2420 100%);
            color: #f5e6d3;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        #gameContainer {
            max-width: 1200px;
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        }
        #connectionPanel {
            text-align: center;
            padding: 30px;
        }
        #connectionPanel h1 {
            color: #d4af37;
            margin-bottom: 30px;
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        .connection-info {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        input, button {
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            border: none;
            font-size: 16px;
        }
        button {
            background: #d4af37;
            color: #2c1810;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover { background: #e5c348; transform: scale(1.05); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #gameBoard {
            display: none;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(6, 60px);
            grid-template-rows: repeat(6, 60px);
            gap: 2px;
            background: #8b7355;
            padding: 10px;
            border-radius: 10px;
            position: relative;
        }
        .space {
            width: 60px;
            height: 60px;
            border: 2px solid #5a4a3a;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
        }
        .space.blue { background: linear-gradient(135deg, #2e5090, #4a7cc7); }
        .space.red { background: linear-gradient(135deg, #8b2020, #c73a3a); }
        .space:hover { border-color: #d4af37; transform: scale(1.05); }
        .tile {
            width: 50px;
            height: 50px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
            color: white;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
        }
        .tile.blue { background: linear-gradient(135deg, #1e3a6f, #3a5c9e); }
        .tile.red { background: linear-gradient(135deg, #6b1f1f, #9e3a3a); }
        .tile.dolos { background: radial-gradient(circle, #4a4a4a, #1a1a1a); }
        .tile.facedown { background: #3a3a3a; color: transparent; }
        #playerInfo {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
        }
        .tokenStorage {
            min-height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed #d4af37;
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .tokenStorage.dragover {
            background: rgba(212, 175, 55, 0.2);
            border-color: #ffff00;
        }
        #hand {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            min-height: 60px;
        }
        .handTile {
            width: 50px;
            height: 50px;
            border: 2px solid #d4af37;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 20px;
            color: white;
            transition: all 0.3s;
        }
        .handTile.blue { background: linear-gradient(135deg, #1e3a6f, #3a5c9e); }
        .handTile.red { background: linear-gradient(135deg, #6b1f1f, #9e3a3a); }
        .handTile.dolos { background: radial-gradient(circle, #4a4a4a, #1a1a1a) !important; }
        .handTile:hover { transform: scale(1.1); }
        .handTile.selected { border-color: #ffff00; box-shadow: 0 0 15px #ffff00; }
        #successTokenDisplay {
            position: absolute;
            top: -40px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            padding: 0 10px;
        }
        .successToken {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            cursor: grab;
            position: absolute;
            z-index: 100;
            transition: none;
        }
        .successToken:active {
            cursor: grabbing;
        }
        .successToken.dragging {
            opacity: 0.5;
            z-index: 1000;
        }
        .successToken.zeus { background: #6a6a6a; }
        .successToken.apollo { background: #f4a460; }
        .successToken.athena { background: #d8bfd8; }
        .successToken.poseidon { background: #4682b4; }
        .successToken.aphrodite { background: #ff69b4; }
        .successToken.positive { background: #ffd700; }
        .successToken.negative { background: #8b0000; color: white; }
        .successToken.marriage { background: #90ee90; }
        .tile-mark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            color: #ff0000;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }
        #message {
            text-align: center;
            padding: 10px;
            background: rgba(212, 175, 55, 0.2);
            border-radius: 5px;
            margin-top: 10px;
            min-height: 40px;
        }
        #debugInfo {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="connectionPanel">
            <h1>⚔️ ILIAD ⚔️</h1>
            <div class="connection-info">
                <h3>Start or Join Game</h3>
                <p>Your ID: <strong id="myId">Generating...</strong></p>
                <button id="copyId">Copy My ID</button>
                <br><br>
                <input type="text" id="peerId" placeholder="Enter opponent's ID">
                <button id="connectBtn">Connect</button>
                <br><br>
                <p id="status">Waiting for connection...</p>
            </div>
        </div>
        
        <div id="gameBoard">
            <div id="playerInfo">
                <h3 id="playerRole"></h3>
                <div>Mode: <span id="currentTurn"></span></div>
                <div>Your Token Storage:</div>
                <div id="myTokenStorage" class="tokenStorage"></div>
                <div>Hand: <span id="handCount"></span></div>
                <div id="hand"></div>
                <button id="drawTile" style="margin-top: 10px;">Draw Tile</button>
                <button id="checkLines" style="margin-top: 10px;">Check for Scoring Lines</button>
                <div id="debugInfo"></div>
            </div>
            
            <div>
                <div id="successTokenDisplay"></div>
                <div id="board"></div>
                <div id="message"></div>
                <div id="tileReference" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-top: 15px;">
                    <h4 style="color: #d4af37; margin-bottom: 10px;">Tile Effects Reference</h4>
                    <div style="font-size: 14px;">
                        <div><strong>1:</strong> Reposition one opponent's accessible tile</div>
                        <div><strong>2:</strong> Reposition one of your own accessible tiles</div>
                        <div><strong>3:</strong> Swap a success token (after scoring a line)</div>
                        <div><strong>4:</strong> Flip this tile and one opponent neighbor tile</div>
                        <div><strong>5:</strong> No effect</div>
                        <div><strong>✦ (Dolos):</strong> No effect (counts as 0 in scoring)</div>
                    </div>
                </div>
            </div>
            
            <div id="opponentInfo">
                <h3>Opponent</h3>
                <div>Their Token Storage:</div>
                <div id="oppTokenStorage" class="tokenStorage"></div>
            </div>
        </div>
    </div>

    <script>
        const GODS = ['Zeus', 'Apollo', 'Athena', 'Poseidon', 'Aphrodite'];
        const TILE_VALUES = [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 'D', 'D', 'D'];  // 18 tiles per player
        
        let peer, conn;
        let myId, isHost;
        let gameState = {
            board: Array(36).fill(null),
            currentPlayer: 'blue',
            blueTokens: [],
            redTokens: [],
            successTokens: [],
            tokenPositions: {},  // Track positions of all tokens
            blueDeck: [],
            redDeck: [],
            blueHand: [],
            redHand: [],
            phase: 'setup'
        };
        let selectedTile = null;
        let myColor = null;
        let effectMode = null;
        let effectData = null;
        let selectedBoardTile = null;  // Track selected tile from board
        let markedTiles = new Set();  // Track tiles marked with X

        // Initialize PeerJS
        peer = new Peer();
        
        peer.on('open', id => {
            document.getElementById('myId').textContent = id;
            myId = id;
        });

        peer.on('connection', connection => {
            conn = connection;
            isHost = true;
            myColor = 'blue';
            setupConnection();
            initGame();
        });

        document.getElementById('copyId').addEventListener('click', () => {
            navigator.clipboard.writeText(myId);
            document.getElementById('status').textContent = 'ID copied!';
            setTimeout(() => {
                document.getElementById('status').textContent = 'Waiting for connection...';
            }, 2000);
        });

        document.getElementById('connectBtn').addEventListener('click', () => {
            const peerId = document.getElementById('peerId').value;
            if (peerId && peerId !== myId) {
                conn = peer.connect(peerId);
                isHost = false;
                myColor = 'red';
                conn.on('open', () => {
                    setupConnection();
                });
            }
        });

        function setupConnection() {
            document.getElementById('status').textContent = 'Connected!';
            document.getElementById('connectionPanel').style.display = 'none';
            document.getElementById('gameBoard').style.display = 'grid';
            
            conn.on('data', data => {
                if (data.type === 'gameState') {
                    gameState = data.state;
                    updateDisplay();
                    showMessage(`Game state received. Your hand has ${(myColor === 'blue' ? gameState.blueHand : gameState.redHand).length} tiles`);
                } else if (data.type === 'move') {
                    handleOpponentMove(data);
                }
            });
            
            conn.on('close', () => {
                showMessage('Opponent disconnected');
            });
            
            if (isHost) {
                setTimeout(() => sendGameState(), 100);
            }
        }

        function initGame() {
            // Setup board spaces
            for (let i = 0; i < 36; i++) {
                const row = Math.floor(i / 6);
                const col = i % 6;
                const isBlue = (row % 2 === 0) ? (col % 2 === 0) : (col % 2 === 1);
                gameState.board[i] = { color: isBlue ? 'blue' : 'red', tile: null };
            }
            
            // Setup success tokens
            setupSuccessTokens();
            
            // Setup decks
            gameState.blueDeck = shuffleArray([...TILE_VALUES]);
            gameState.redDeck = shuffleArray([...TILE_VALUES]);
            
            // Initial draw
            for (let i = 0; i < 2; i++) {
                gameState.blueHand.push(gameState.blueDeck.pop());
                gameState.redHand.push(gameState.redDeck.pop());
            }
            
            updateDisplay();
            showMessage('Game initialized! Blue starts.');
        }

        function setupSuccessTokens() {
            const tokens = [];
            GODS.forEach(god => {
                tokens.push({ type: 'god', god, value: Math.floor(Math.random() * 10) + 1, id: `token-${god}` });
            });
            tokens.push({ type: 'positive', item: 'Shield', value: 10, id: 'token-shield' });
            tokens.push({ type: 'positive', item: 'Spear', value: 10, id: 'token-spear' });
            tokens.push({ type: 'positive', item: 'Chariot', value: 10, id: 'token-chariot' });
            tokens.push({ type: 'negative', item: 'Morale', value: -3, id: 'token-morale' });
            tokens.push({ type: 'negative', item: 'Plague', value: -5, id: 'token-plague' });
            tokens.push({ type: 'negative', item: 'Firestorm', value: -10, id: 'token-firestorm' });
            tokens.push({ type: 'marriage', value: 0, id: 'token-marriage1' });
            tokens.push({ type: 'marriage', value: 0, id: 'token-marriage2' });
            
            let displayTokens = shuffleArray(tokens);
            while (displayTokens.slice(0, 5).filter(t => t.value < 0).length > 0) {
                displayTokens = shuffleArray(tokens);
            }
            
            // Initialize token positions around the board
            displayTokens.forEach((token, i) => {
                const angle = (i / displayTokens.length) * Math.PI * 2;
                const radius = 220;
                const centerX = 190;
                const centerY = 190;
                gameState.tokenPositions[token.id] = {
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius,
                    location: 'board'
                };
            });
            
            gameState.successTokens = displayTokens;
        }

        function updateDisplay() {
            // Update player info
            document.getElementById('playerRole').textContent = 
                myColor === 'blue' ? '🛡️ Hector (Blue)' : '⚔️ Achilles (Red)';
            document.getElementById('currentTurn').textContent = 'Free Play Mode';
            
            // Update board
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            gameState.board.forEach((space, i) => {
                const spaceEl = document.createElement('div');
                spaceEl.className = `space ${space.color}`;
                spaceEl.dataset.index = i;
                
                if (space.tile) {
                    const tileEl = document.createElement('div');
                    tileEl.className = `tile ${space.tile.color}`;
                    if (space.tile.facedown) {
                        tileEl.classList.add('facedown');
                    } else if (space.tile.value === 'D') {
                        tileEl.classList.add('dolos');
                        tileEl.textContent = '✦';
                    } else {
                        tileEl.textContent = space.tile.value;
                    }
                    
                    // Add X mark if tile is marked
                    if (markedTiles.has(i)) {
                        const markEl = document.createElement('div');
                        markEl.className = 'tile-mark';
                        markEl.textContent = '✕';
                        tileEl.appendChild(markEl);
                    }
                    
                    spaceEl.appendChild(tileEl);
                }
                
                if (selectedBoardTile === i) {
                    spaceEl.style.border = '3px solid #ffff00';
                    spaceEl.style.boxShadow = '0 0 10px #ffff00';
                }
                
                spaceEl.addEventListener('click', () => handleBoardClick(i));
                
                // Add right-click to mark tiles
                spaceEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    
                    if (space.tile) {
                        if (markedTiles.has(i)) {
                            markedTiles.delete(i);
                            showMessage("Removed X mark");
                        } else {
                            markedTiles.add(i);
                            showMessage("Added X mark");
                        }
                        updateDisplay();
                        
                        // Send mark update to opponent
                        sendMove({ action: 'toggleMark', index: i, marked: markedTiles.has(i) });
                    }
                });
                boardEl.appendChild(spaceEl);
            });
            
            updateBoardTokens();
            updateHand();
        }

        function updateHand() {
            const handEl = document.getElementById('hand');
            handEl.innerHTML = '';
            const myHand = myColor === 'blue' ? gameState.blueHand : gameState.redHand;
            
            document.getElementById('handCount').textContent = `(${myHand.length} tiles)`;
            
            myHand.forEach((tile, i) => {
                const tileEl = document.createElement('div');
                tileEl.className = `handTile ${myColor}`;
                
                if (tile === 'D') {
                    tileEl.classList.add('dolos');
                    tileEl.textContent = '✦';
                } else {
                    tileEl.textContent = tile;
                }
                
                if (selectedTile === i) {
                    tileEl.classList.add('selected');
                }
                
                tileEl.addEventListener('click', () => selectTile(i));
                handEl.appendChild(tileEl);
            });
            
            // Debug info
            document.getElementById('debugInfo').innerHTML = `
                Deck: ${(myColor === 'blue' ? gameState.blueDeck : gameState.redDeck).length}/18 tiles remaining<br>
                Hand values: [${myHand.join(', ')}]
            `;
        }

        function updateTokenDisplay() {
            const myTokensEl = document.getElementById('myTokens');
            const oppTokensEl = document.getElementById('oppTokens');
            const myTokens = myColor === 'blue' ? gameState.blueTokens : gameState.redTokens;
            const oppTokens = myColor === 'blue' ? gameState.redTokens : gameState.blueTokens;
            
            myTokensEl.innerHTML = '';
            oppTokensEl.innerHTML = '';
            
            myTokens.forEach(token => {
                const tokenEl = createTokenElement(token);
                myTokensEl.appendChild(tokenEl);
            });
            
            oppTokens.forEach(token => {
                const tokenEl = createTokenElement(token);
                oppTokensEl.appendChild(tokenEl);
            });
        }

        function createTokenElement(token) {
            const tokenEl = document.createElement('div');
            tokenEl.className = 'token';
            
            if (token.type === 'god') {
                tokenEl.classList.add(token.god.toLowerCase());
                tokenEl.textContent = token.god[0] + token.value;
            } else if (token.type === 'positive') {
                tokenEl.classList.add('positive');
                tokenEl.textContent = '+' + token.value;
            } else if (token.type === 'negative') {
                tokenEl.classList.add('negative');
                tokenEl.textContent = token.value;
            } else if (token.type === 'marriage') {
                tokenEl.classList.add('marriage');
                tokenEl.textContent = '💍';
            }
            
            return tokenEl;
        }

        function updateBoardTokens() {
            // Remove old token display
            document.getElementById('successTokenDisplay').innerHTML = '';
            
            // Remove existing draggable tokens
            document.querySelectorAll('.successToken').forEach(el => el.remove());
            
            // Remove old event listeners
            const boardContainer = document.getElementById('board').parentElement;
            const newBoardContainer = boardContainer.cloneNode(true);
            boardContainer.parentNode.replaceChild(newBoardContainer, boardContainer);
            
            const boardEl = newBoardContainer.querySelector('#board');
            boardEl.innerHTML = '';
            
            // Recreate board spaces
            gameState.board.forEach((space, i) => {
                const spaceEl = document.createElement('div');
                spaceEl.className = `space ${space.color}`;
                spaceEl.dataset.index = i;
                
                if (space.tile) {
                    const tileEl = document.createElement('div');
                    tileEl.className = `tile ${space.tile.color}`;
                    if (space.tile.facedown) {
                        tileEl.classList.add('facedown');
                    } else if (space.tile.value === 'D') {
                        tileEl.classList.add('dolos');
                        tileEl.textContent = '✦';
                    } else {
                        tileEl.textContent = space.tile.value;
                    }
                    
                    // Add X mark if tile is marked
                    if (markedTiles.has(i)) {
                        const markEl = document.createElement('div');
                        markEl.className = 'tile-mark';
                        markEl.textContent = '✕';
                        tileEl.appendChild(markEl);
                    }
                    
                    spaceEl.appendChild(tileEl);
                }
                
                if (selectedBoardTile === i) {
                    spaceEl.style.border = '3px solid #ffff00';
                    spaceEl.style.boxShadow = '0 0 10px #ffff00';
                }
                
                spaceEl.addEventListener('click', () => handleBoardClick(i));
                
                // Add right-click to mark tiles
                spaceEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    
                    if (space.tile) {
                        if (markedTiles.has(i)) {
                            markedTiles.delete(i);
                            showMessage("Removed X mark");
                        } else {
                            markedTiles.add(i);
                            showMessage("Added X mark");
                        }
                        updateDisplay();
                        
                        // Send mark update to opponent
                        sendMove({ action: 'toggleMark', index: i, marked: markedTiles.has(i) });
                    }
                });
                
                boardEl.appendChild(spaceEl);
            });
            
            newBoardContainer.style.position = 'relative';
            
            // Create draggable tokens
            gameState.successTokens.forEach(token => {
                const tokenEl = document.createElement('div');
                tokenEl.className = 'successToken';
                tokenEl.id = token.id;
                tokenEl.draggable = true;
                
                // Set token appearance
                if (token.type === 'god') {
                    tokenEl.classList.add(token.god.toLowerCase());
                    tokenEl.textContent = token.god[0] + token.value;
                    tokenEl.title = `${token.god}: ${token.value}`;
                } else if (token.type === 'positive') {
                    tokenEl.classList.add('positive');
                    tokenEl.textContent = '+' + token.value;
                    tokenEl.title = `${token.item}: +${token.value}`;
                } else if (token.type === 'negative') {
                    tokenEl.classList.add('negative');
                    tokenEl.textContent = token.value;
                    tokenEl.title = `${token.item}: ${token.value}`;
                } else if (token.type === 'marriage') {
                    tokenEl.classList.add('marriage');
                    tokenEl.textContent = '💍';
                    tokenEl.title = 'Marriage to Helen';
                }
                
                // Set position
                const pos = gameState.tokenPositions[token.id];
                if (pos.location === 'board') {
                    tokenEl.style.left = pos.x + 'px';
                    tokenEl.style.top = pos.y + 'px';
                    newBoardContainer.appendChild(tokenEl);
                } else if (pos.location === myColor) {
                    tokenEl.style.position = 'relative';
                    tokenEl.style.left = '';
                    tokenEl.style.top = '';
                    document.getElementById('myTokenStorage').appendChild(tokenEl);
                } else if (pos.location === (myColor === 'blue' ? 'red' : 'blue')) {
                    tokenEl.style.position = 'relative';
                    tokenEl.style.left = '';
                    tokenEl.style.top = '';
                    document.getElementById('oppTokenStorage').appendChild(tokenEl);
                }
                
                // Add drag event listeners
                tokenEl.addEventListener('dragstart', handleTokenDragStart);
                tokenEl.addEventListener('dragend', handleTokenDragEnd);
            });
            
            // Add drop zone listeners
            newBoardContainer.addEventListener('dragover', handleBoardDragOver);
            newBoardContainer.addEventListener('drop', handleBoardDrop);
            
            const myStorage = document.getElementById('myTokenStorage');
            const newMyStorage = myStorage.cloneNode(false);
            myStorage.parentNode.replaceChild(newMyStorage, myStorage);
            
            // Move tokens to new storage
            document.querySelectorAll('.successToken').forEach(token => {
                const pos = gameState.tokenPositions[token.id];
                if (pos && pos.location === myColor) {
                    newMyStorage.appendChild(token);
                }
            });
            
            newMyStorage.addEventListener('dragover', handleStorageDragOver);
            newMyStorage.addEventListener('drop', handleStorageDrop);
            newMyStorage.addEventListener('dragleave', handleStorageDragLeave);
        }
        
        let draggedToken = null;
        
        function handleTokenDragStart(e) {
            draggedToken = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleTokenDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedToken = null;
        }
        
        function handleBoardDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        
        function handleBoardDrop(e) {
            e.preventDefault();
            if (!draggedToken) return;
            
            const boardContainer = document.getElementById('board').parentElement;
            const rect = boardContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const tokenId = draggedToken.id;
            gameState.tokenPositions[tokenId] = { x, y, location: 'board' };
            
            draggedToken.style.position = 'absolute';
            draggedToken.style.left = x + 'px';
            draggedToken.style.top = y + 'px';
            boardContainer.appendChild(draggedToken);
            
            sendMove({ action: 'moveToken', tokenId, position: gameState.tokenPositions[tokenId] });
        }
        
        function handleStorageDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.currentTarget.classList.add('dragover');
        }
        
        function handleStorageDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }
        
        function handleStorageDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            if (!draggedToken) return;
            
            const tokenId = draggedToken.id;
            gameState.tokenPositions[tokenId] = { x: 0, y: 0, location: myColor };
            
            draggedToken.style.position = 'relative';
            draggedToken.style.left = '';
            draggedToken.style.top = '';
            e.currentTarget.appendChild(draggedToken);
            
            sendMove({ action: 'moveToken', tokenId, position: gameState.tokenPositions[tokenId] });
        }

        function getGodColor(god) {
            const colors = {
                'Zeus': '#6a6a6a',
                'Apollo': '#f4a460',
                'Athena': '#d8bfd8',
                'Poseidon': '#4682b4',
                'Aphrodite': '#ff69b4'
            };
            return colors[god] || '#808080';
        }

        function selectTile(index) {
            selectedTile = selectedTile === index ? null : index;
            updateHand();
            if (selectedTile !== null) {
                const myHand = myColor === 'blue' ? gameState.blueHand : gameState.redHand;
                showMessage(`Selected tile: ${myHand[selectedTile]}`);
            }
        }

        function handleBoardClick(index) {
            if (effectMode) {
                handleEffectClick(index);
                return;
            }
            
            const space = gameState.board[index];
            
            // If clicking on an existing tile
            if (space.tile) {
                // Only allow picking up your own tiles (unless in effect mode)
                if (space.tile.color === myColor) {
                    if (selectedBoardTile === index) {
                        // Deselect if clicking same tile
                        selectedBoardTile = null;
                        showMessage("Tile deselected");
                    } else {
                        // Pick up the tile
                        selectedBoardTile = index;
                        selectedTile = null; // Deselect hand tile if any
                        showMessage(`Picked up ${space.tile.value} tile. Click empty space to reposition.`);
                    }
                    updateDisplay();
                    return;
                } else {
                    showMessage("You can only move your own tiles!");
                    return;
                }
            }
            
            // If we have a board tile selected, try to place it
            if (selectedBoardTile !== null) {
                const sourceTile = gameState.board[selectedBoardTile].tile;
                
                // Check if new position is valid
                if (space.color !== myColor && !hasNeighborExcept(index, selectedBoardTile)) {
                    showMessage("Can only place on your color or adjacent to existing tiles!");
                    return;
                }
                
                // Move the tile
                gameState.board[selectedBoardTile].tile = null;
                space.tile = sourceTile;
                
                // Send move
                sendMove({ action: 'reposition', from: selectedBoardTile, to: index, tile: sourceTile });
                
                selectedBoardTile = null;
                updateDisplay();
                showMessage(`Moved tile to new position`);
                return;
            }
            
            // If we have a hand tile selected, place it normally
            if (selectedTile === null) {
                showMessage("Select a tile from your hand or board first!");
                return;
            }
            
            if (space.color !== myColor && !hasNeighbor(index)) {
                showMessage("Can only place on your color or adjacent to existing tiles!");
                return;
            }
            
            const myHand = myColor === 'blue' ? gameState.blueHand : gameState.redHand;
            const tileValue = myHand[selectedTile];
            
            // Place tile
            space.tile = { value: tileValue, color: myColor, facedown: false };
            myHand.splice(selectedTile, 1);
            selectedTile = null;
            
            // Send move first
            sendMove({ action: 'placeTile', index, tile: space.tile });
            
            // Apply effect
            if (tileValue !== 'D' && tileValue !== 5) {
                applyTileEffect(tileValue, index);
            }
            
            updateDisplay();
        }

        function hasNeighbor(index) {
            const neighbors = getNeighbors(index);
            return neighbors.some(i => gameState.board[i] && gameState.board[i].tile);
        }

        function getNeighbors(index) {
            const neighbors = [];
            const row = Math.floor(index / 6);
            const col = index % 6;
            
            if (row > 0) neighbors.push(index - 6);
            if (row < 5) neighbors.push(index + 6);
            if (col > 0) neighbors.push(index - 1);
            if (col < 5) neighbors.push(index + 1);
            
            return neighbors;
        }

        function getGodColor(god) {
            const colors = {
                'Zeus': '#6a6a6a',
                'Apollo': '#f4a460',
                'Athena': '#d8bfd8',
                'Poseidon': '#4682b4',
                'Aphrodite': '#ff69b4'
            };
            return colors[god] || '#808080';
        }

        function hasNeighborExcept(index, exceptIndex) {
            const neighbors = getNeighbors(index);
            return neighbors.some(i => i !== exceptIndex && gameState.board[i] && gameState.board[i].tile);
        }

        function applyTileEffect(value, index) {
            switch(value) {
                case 1:
                    showMessage("Effect: Click an opponent's tile to reposition");
                    effectMode = 'reposition-opponent';
                    break;
                case 2:
                    showMessage("Effect: Click your tile to reposition");
                    effectMode = 'reposition-own';
                    break;
                case 3:
                    showMessage("Effect: Token swap not implemented - no effect");
                    // Token swapping would need to be implemented after line scoring
                    break;
                case 4:
                    showMessage("Effect: Tiles flipped!");
                    effectMode = 'flip';
                    effectData = index;
                    handleFlipEffect(index);
                    break;
                default:
                    break;
            }
        }

        function handleEffectClick(index) {
            const space = gameState.board[index];
            
            if (effectMode === 'reposition-opponent') {
                if (space.tile && space.tile.color !== myColor && isAccessible(index)) {
                    const tile = space.tile;
                    space.tile = null;
                    effectMode = 'place-repositioned';
                    effectData = tile;
                    showMessage("Click empty space to place tile");
                    sendMove({ action: 'reposition', from: index });
                }
            } else if (effectMode === 'reposition-own') {
                if (space.tile && space.tile.color === myColor && isAccessible(index)) {
                    const tile = space.tile;
                    space.tile = null;
                    effectMode = 'place-repositioned';
                    effectData = tile;
                    showMessage("Click empty space to place tile");
                    sendMove({ action: 'reposition', from: index });
                }
            } else if (effectMode === 'place-repositioned') {
                if (!space.tile && (space.color === effectData.color || hasNeighbor(index))) {
                    space.tile = effectData;
                    effectMode = null;
                    effectData = null;
                    sendMove({ action: 'placeRepositioned', to: index, tile: space.tile });
                }
            }
            
            updateDisplay();
        }

        function isAccessible(index) {
            const neighbors = getNeighbors(index);
            return neighbors.some(i => !gameState.board[i] || !gameState.board[i].tile);
        }

        function handleFlipEffect(index) {
            const space = gameState.board[index];
            space.tile.facedown = true;
            
            const neighbors = getNeighbors(index);
            const oppTiles = neighbors.filter(i => 
                gameState.board[i] && gameState.board[i].tile && 
                gameState.board[i].tile.color !== myColor
            );
            
            if (oppTiles.length > 0) {
                gameState.board[oppTiles[0]].tile.facedown = true;
            }
            
            effectMode = null;
            sendMove({ action: 'flip', index, flipped: oppTiles[0] });
        }

        function checkLines() {
            // Check rows
            for (let row = 0; row < 6; row++) {
                if (isLineFull(row * 6, 1)) {
                    scoreLine(row * 6, 1);
                }
            }
            // Check columns
            for (let col = 0; col < 6; col++) {
                if (isLineFull(col, 6)) {
                    scoreLine(col, 6);
                }
            }
        }

        function isLineFull(start, step) {
            for (let i = 0; i < 6; i++) {
                if (!gameState.board[start + i * step].tile) return false;
            }
            return true;
        }

        function scoreLine(start, step) {
            const blueTiles = [];
            const redTiles = [];
            
            for (let i = 0; i < 6; i++) {
                const tile = gameState.board[start + i * step].tile;
                if (tile && !tile.facedown) {
                    if (tile.color === 'blue') {
                        blueTiles.push(tile.value === 'D' ? 0 : tile.value);
                    } else {
                        redTiles.push(tile.value === 'D' ? 0 : tile.value);
                    }
                }
            }
            
            const blueScore = blueTiles.reduce((a, b) => a + b, 0);
            const redScore = redTiles.reduce((a, b) => a + b, 0);
            
            showMessage(`Line scored! Blue: ${blueScore}, Red: ${redScore}`);
        }

        function endTurn() {
            checkLines();
            updateDisplay();
            sendGameState();
        }

        function handleOpponentMove(data) {
            if (data.action === 'placeTile') {
                gameState.board[data.index].tile = data.tile;
            } else if (data.action === 'reposition') {
                gameState.board[data.from].tile = null;
                gameState.board[data.to].tile = data.tile;
            } else if (data.action === 'placeRepositioned') {
                gameState.board[data.to].tile = data.tile;
            } else if (data.action === 'flip') {
                gameState.board[data.index].tile.facedown = true;
                if (data.flipped !== undefined) {
                    gameState.board[data.flipped].tile.facedown = true;
                }
            } else if (data.action === 'toggleMark') {
                if (data.marked) {
                    markedTiles.add(data.index);
                } else {
                    markedTiles.delete(data.index);
                }
            } else if (data.action === 'moveToken') {
                gameState.tokenPositions[data.tokenId] = data.position;
            }
            updateDisplay();
        }

        function sendMove(move) {
            if (conn && conn.open) {
                conn.send({ type: 'move', ...move });
            }
        }

        function sendGameState() {
            if (conn && conn.open) {
                conn.send({ type: 'gameState', state: gameState });
            }
        }

        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        document.getElementById('drawTile').addEventListener('click', () => {
            const myHand = myColor === 'blue' ? gameState.blueHand : gameState.redHand;
            const myDeck = myColor === 'blue' ? gameState.blueDeck : gameState.redDeck;
            
            if (myHand.length < 2 && myDeck.length > 0) {
                myHand.push(myDeck.pop());
                updateDisplay();
                sendGameState();
                showMessage(`Drew tile: ${myHand[myHand.length - 1]}`);
            } else if (myDeck.length === 0) {
                showMessage("No more tiles in deck!");
            } else {
                showMessage("Hand is full (max 2 tiles)!");
            }
        });
        
        document.getElementById('checkLines').addEventListener('click', () => {
            checkLines();
            sendGameState();
        });
    </script>
</body>
</html>
